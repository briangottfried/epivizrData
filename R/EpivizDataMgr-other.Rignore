#     actionMap <<- list(
#       getMeasurements=function(mgr, msgData, ...) { mgr$getMeasurements() },
#       getRows=function(mgr, msgData, ...) { mgr$getRows(msgData$seqName, msgData$start, msgData$end, msgData$metadata, msgData$datasource) },
#       getValues=function(mgr, msgData, ...) { mgr$getValues(msgData$seqName, msgData$start, msgData$end, msgData$datasource, msgData$measurement) },
#       getSeqInfos=function(mgr, msgData, ...) { mgr$getSeqInfos() }
#     )

# daemonization helpers
EpivizDeviceMgr$methods(list(
  daemonized=function() server$daemonized,
  waitToClearRequests=function(timeout=3L) {
    ptm <- proc.time()
    while (server$requestWaiting && (proc.time() - ptm < timeout)["elapsed"]) {
      Sys.sleep(0.001)
      service()
    }
    if (server$requestWaiting) {
      stop("requests not cleared")
    }
    return(invisible())
  }
))

# measurement management methods
.typeMap <- list(gene=list(class="EpivizFeatureData",
                           description="Data indexed by feature",
                           input_class="RangedSummarizedExperiment"),
                 bp=list(class="EpivizBpData",
                         description="Basepair resolution data",
                         input_class="GRanges"),
                 block=list(class="EpivizBlockData",
                            description="Genomic region data",
                            input_class="GRanges"),
                 wig=list(class="EpivizWigData",
                          description="Genomic continuous data from wig file",
                          input_class="BigWigFile"),
                 geneInfo=list(class="EpivizGeneInfoData",
                               description="Gene annotation data",
                               input_class="GRanges"))

EpivizDeviceMgr$methods(list(
  addMeasurements=function(obj, msName, sendRequest=!nonInteractive, ...) {
    'add measurements to epiviz session'
    epivizObject <- epivizr:::register(obj, ...)
    type <- .self$getMeasurementType(epivizObject)
    
    msIdCounter <<- msIdCounter + 1L
    msId <- sprintf("epivizMs_%s_%d", type, msIdCounter)
    epivizObject$setId(msId)
    epivizObject$setName(msName)
    epivizObject$setMgr(.self)
    
    measurements <- epivizObject$getMeasurements()
    msRecord <- list(measurements=measurements,
                     name=msName, obj=epivizObject, connected=FALSE)
    msList[[type]][[msId]] <<- msRecord
    
    if (sendRequest) {
      callback <- function(data) {
        msList[[type]][[msId]][["connected"]] <<- TRUE
        epivizrMsg("Measurement ", msName, " added to browser and connected", tagPrompt=TRUE)
      }
      requestId <- callbackArray$append(callback)
      request <- list(requestId=requestId,
                      type="request")
      request$data <- list(action="addMeasurements",
                           measurements=toJSON(measurements))
      server$sendRequest(request)
    }
    return(epivizObject)
  },
  .clearDatasourceGroupCache=function(msObj, sendRequest=!nonInteractive) {
    if(!is(msObj, "EpivizData")) {
      stop("'msObj' must be an 'EpivizData' object")
    }
    msType <- getMeasurementType(msObj)
    if (!exists(msObj$getId(), envir=msList[[msType]], inherits=FALSE))
      stop("did not find object")
    
    if (sendRequest) {
      callback <- function(data) {
        if (verbose) epivizrMsg("DatasourceGroup caches cleared", tagPrompt=TRUE)
      }
      callback2 <- function(data) {
        if (verbose) epivizrMsg("Redrawn", tagPrompt=TRUE)
      }
      
      requestId <- callbackArray$append(callback)
      request <- list(requestId=requestId,
                      type="request",
                      data=list(action="clearDatasourceGroupCache",
                                datasourceGroup=msObj$getId()))
      server$sendRequest(request)
      
      requestId <- callbackArray$append(callback2)
      request <- list(requestId=requestId,
                      type="request",
                      data=list(action="redraw"))
      server$sendRequest(request)
    }
    invisible()
  },
  updateMeasurements=function(oldObject, newObject, sendRequest=!nonInteractive) {
    if (is.character(oldObject))
      oldObject <- .getMsObject(oldObject)
    if (!is(oldObject, "EpivizData"))
      stop("oldObject must be of class 'EpivizData'")
    oldObject$update(newObject, sendRequest=sendRequest)
    invisible()
  },
  .getMsObject=function(msObjId) {
    slot <- sapply(msList, function(typeList) exists(msObjId, typeList, inherits=FALSE))
    if (!any(slot)) {
      stop("could not find measurement object")
    }
    slot <- which(slot)
    typeList <- msList[[slot]]
    msRecord <- get(msObjId, envir=typeList, inherits=FALSE)
    msRecord$obj
  },
  rmMeasurements=function(msObj) {
    if (is.character(msObj)) {
      # passed the id instead of the object
      msObj <- .self$.getMsObject(msObj)
    }
    
    if (!is(msObj, "EpivizData")) {
      stop("'msObj' must be an 'EpivizData' object")
    }
    
    msType <- .self$getMeasurementType(msObj)
    typeList <- msList[[msType]]
    
    if (!exists(msObj$getId(), envir=typeList, inherits=FALSE))
      stop("object not found")
    
    objRecord <- get(msObj$getId(), typeList, inherits=FALSE)
    msName <- objRecord$name
    ms <- objRecord$obj$getMeasurements()
    
    rm(list=msObj$getId(), envir=msList[[msType]])
    if(objRecord$connected) {
      callback=function(data) {
        epivizrMsg("measurement object ", msName, " removed and disconnected", tagPrompt=TRUE)
      }
      requestId=callbackArray$append(callback)
      request <- list(requestId=requestId,
                      type="request")
      request$data <- list(action="removeMeasurements",
                           measurements=toJSON(ms))
      server$sendRequest(request)
    }
    invisible(NULL)
  },
  rmAllMeasurements=function(which=c("noDevice", "onlyDevice", "all")) {
    which <- match.arg(which)
    for (i in seq_along(msList)) {
      curType=names(msList)[i]
      ids <- ls(msList[[curType]])
      if (length(ids)>0) {
        for (id in ids) {
          objRecord <- msList[[curType]][[id]]
          if((!objRecord$obj$inDevice && (which %in% c("noDevice", "all")) ||
              (objRecord$obj$inDevice && (which %in% c("onlyDevice", "all")))))
            rmMeasurements(objRecord$obj)
        }
      }
    }
  },
  listMeasurements=function(onlyLocal=TRUE) {
    if (!onlyLocal) {
      stop("'onlyLocal=FALSE' not implemented yet")
    }
    
    .doOneList <- function(ms) {
      ids <- ls(ms)
      nms <- sapply(ids, function(id) ms[[id]]$name)
      lens <- sapply(ids, function(id) length(ms[[id]]$obj$object))
      connected <- ifelse(sapply(ids, function(id) ms[[id]]$connected), "*", "")
      columns <- sapply(ids, function(id) paste0(ms[[id]]$obj$columns,collapse=","))
      
      data.frame(id=ids,
                 name=nms,
                 length=lens,
                 connected=connected,
                 columns=columns,
                 stringsAsFactors=FALSE,row.names=NULL)
    }
    out <- list()
    for (i in seq_along(msList)) {
      curType=names(msList)[i]
      if (length(ls(msList[[curType]])>0)) {
        out[[curType]] <- .doOneList(msList[[curType]])
      } else {
        out[[curType]] <- NULL
      }
    }
    return(out)
  },
  getMeasurements=function() {
    out <- list(id=character(),
                name=character(),
                type=character(),
                datasourceId=character(),
                datasourceGroup=character(),
                defaultChartType=character(),
                annotation=list(),
                minValue=numeric(),
                maxValue=numeric(),
                metadata=list()
    )
    for (i in seq_along(typeMap)) {
      curType <- names(typeMap)[i]
      nm <- paste0(curType,"Measurements")
      measurements <- list()
      
      ids <- ls(msList[[curType]])
      if (length(ids)>0) {
        for (id in ids) {
          msRecord <- msList[[curType]][[id]]
          ms <- msRecord$obj$getMeasurements()
          for (curMs in ms) {
            for (recName in names(out)) {
              if (is.list(out[[recName]])) {
                curVal <- list(curMs[[recName]])
              } else {
                curVal <- curMs[[recName]]
              }
              if (!is.null(curMs[[recName]])) {
                out[[recName]] <- c(out[[recName]], curVal)
              } else {
                out[[recName]] <- c(out[[recName]], list(NULL))
              }
            }
          }
        }
      }
    }
    
    if (length(out$id)==1) {
      for (recName in names(out)) {
        out[[recName]] <- list(out[[recName]])
      }
    }
    return(out)
  },
  getMeasurementType=function(x) {
    if (!is.character(x)) {
      if (!is(x, "EpivizData")) {
        stop("'x' must be 'character' or an 'EpivizData' object")
      }
      x <- class(x)
    }
    m <- match(x, sapply(typeMap, "[[", "class"))
    if (is.na(m))
      stop("Class ", x, " not found in 'typeMap'")
    names(typeMap)[m]
  }
))

#####
# fetch data method
EpivizDeviceMgr$methods(list(
  .findDatasource=function(datasource) {
    for (msType in names(typeMap)) {
      curMs <- msList[[msType]]
      if (exists(datasource, curMs, inherits=FALSE)) {
        return(curMs[[datasource]]$obj)
      }
    }
    return(NULL)
  },
  getRows=function(chr, start, end, metadata, datasource) {
    if (is.null(chr) || is.null(start) || is.null(end)) {
      query <- NULL
    } else {
      query <- GRanges(chr, ranges=IRanges(start, end))
    }
    obj <- .findDatasource(datasource)
    if (is.null(obj)) {
      stop("cannot find datasource", datasource)
    }
    obj$getRows(query, metadata)
  },
  getValues=function(chr, start, end, datasource, measurement) {
    if (is.null(chr) || is.null(start) || is.null(end)) {
      query <- NULL
    } else {
      query <- GRanges(chr,ranges=IRanges(start,end))
    }
    obj <- .findDatasource(datasource)
    if (is.null(obj)) {
      stop("cannot find datasource", datasource)
    }
    obj$getValues(query, measurement)
  }
))

# TODO: this needs to implemented
EpivizDataMgr$methods(list(
  getSeqInfos=function() {
    return(list())
  })
)


# seqinfos and genes
EpivizDataMgr$methods(
  addSeqinfo=function(x) {
    if (is(x,"Seqinfo")) {
      x <- seqlengths(x)
    }
    
    if (is.null(names(x))) {
      stop("argument 'x' must be a 'Seqinfo' object or a named vector that can be cast to integer")
    }
    
    nms <- names(x)
    x <- tryCatch(as.integer(x),
                  error=function(e) {
                    stop("argument 'x' must be vector that can be cast to integer", e)
                  })
    names(x) <- NULL
    
    out <- lapply(seq(along=x), function(i) {
      list(nms[i], 1, x[i])
    })
    callback <- function(data) {
      invisible(NULL)
    }
    requestId <- callbackArray$append(callback)
    request <- list(type="request",
                    requestId=requestId,
                    data=list(action="addSeqInfos",
                              seqInfos=toJSON(out)))
    server$sendRequest(request)
  },
  
  rmSeqinfo=function(seqnames) {
    callback <- function(data) {
      invisible(NULL)
    }
    requestId <- callbackArray$append(callback)
    request <- list(type="request",
                    requestId=requestId,
                    data=list(action="removeSeqNames",
                              seqNames=toJSON(seqnames)))
    server$sendRequest(request)
  }
)