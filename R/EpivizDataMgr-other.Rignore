#     actionMap <<- list(
#       getMeasurements=function(mgr, msgData, ...) { mgr$getMeasurements() },
#       getRows=function(mgr, msgData, ...) { mgr$getRows(msgData$seqName, msgData$start, msgData$end, msgData$metadata, msgData$datasource) },
#       getValues=function(mgr, msgData, ...) { mgr$getValues(msgData$seqName, msgData$start, msgData$end, msgData$datasource, msgData$measurement) },
#       getSeqInfos=function(mgr, msgData, ...) { mgr$getSeqInfos() }
#     )

# daemonization helpers
EpivizDeviceMgr$methods(list(
  daemonized=function() server$daemonized,
  waitToClearRequests=function(timeout=3L) {
    ptm <- proc.time()
    while (server$requestWaiting && (proc.time() - ptm < timeout)["elapsed"]) {
      Sys.sleep(0.001)
      service()
    }
    if (server$requestWaiting) {
      stop("requests not cleared")
    }
    return(invisible())
  }
))

# measurement management methods
.typeMap <- list(gene=list(class="EpivizFeatureData",
                           description="Data indexed by feature",
                           input_class="RangedSummarizedExperiment"),
                 bp=list(class="EpivizBpData",
                         description="Basepair resolution data",
                         input_class="GRanges"),
                 block=list(class="EpivizBlockData",
                            description="Genomic region data",
                            input_class="GRanges"),
                 wig=list(class="EpivizWigData",
                          description="Genomic continuous data from wig file",
                          input_class="BigWigFile"),
                 geneInfo=list(class="EpivizGeneInfoData",
                               description="Gene annotation data",
                               input_class="GRanges"))


#####
# fetch data method
EpivizDeviceMgr$methods(list(
  .findDatasource=function(datasource) {
    for (msType in names(typeMap)) {
      curMs <- msList[[msType]]
      if (exists(datasource, curMs, inherits=FALSE)) {
        return(curMs[[datasource]]$obj)
      }
    }
    return(NULL)
  },
  getRows=function(chr, start, end, metadata, datasource) {
    if (is.null(chr) || is.null(start) || is.null(end)) {
      query <- NULL
    } else {
      query <- GRanges(chr, ranges=IRanges(start, end))
    }
    obj <- .findDatasource(datasource)
    if (is.null(obj)) {
      stop("cannot find datasource", datasource)
    }
    obj$getRows(query, metadata)
  },
  getValues=function(chr, start, end, datasource, measurement) {
    if (is.null(chr) || is.null(start) || is.null(end)) {
      query <- NULL
    } else {
      query <- GRanges(chr,ranges=IRanges(start,end))
    }
    obj <- .findDatasource(datasource)
    if (is.null(obj)) {
      stop("cannot find datasource", datasource)
    }
    obj$getValues(query, measurement)
  }
))

# TODO: this needs to implemented
EpivizDataMgr$methods(list(
  getSeqInfos=function() {
    return(list())
  })
)


# seqinfos and genes
EpivizDataMgr$methods(
  addSeqinfo=function(x) {
    if (is(x,"Seqinfo")) {
      x <- seqlengths(x)
    }
    
    if (is.null(names(x))) {
      stop("argument 'x' must be a 'Seqinfo' object or a named vector that can be cast to integer")
    }
    
    nms <- names(x)
    x <- tryCatch(as.integer(x),
                  error=function(e) {
                    stop("argument 'x' must be vector that can be cast to integer", e)
                  })
    names(x) <- NULL
    
    out <- lapply(seq(along=x), function(i) {
      list(nms[i], 1, x[i])
    })
    callback <- function(data) {
      invisible(NULL)
    }
    requestId <- callbackArray$append(callback)
    request <- list(type="request",
                    requestId=requestId,
                    data=list(action="addSeqInfos",
                              seqInfos=toJSON(out)))
    server$sendRequest(request)
  },
  
  rmSeqinfo=function(seqnames) {
    callback <- function(data) {
      invisible(NULL)
    }
    requestId <- callbackArray$append(callback)
    request <- list(type="request",
                    requestId=requestId,
                    data=list(action="removeSeqNames",
                              seqNames=toJSON(seqnames)))
    server$sendRequest(request)
  }
)